#include "Lib/All.h"

using namespace std;
using namespace xxx;

#include "lua.hpp"

enum class LuaDataTypes
{
    NoValue, Nil, Boolean, UserData, Number, String, Table, Function, Thread, Proto
};
const LuaDataTypes map_lua_type_enums[] = {
    LuaDataTypes::NoValue,
    LuaDataTypes::Nil, LuaDataTypes::Boolean, LuaDataTypes::UserData, LuaDataTypes::Number,
    LuaDataTypes::String, LuaDataTypes::Table, LuaDataTypes::Function, LuaDataTypes::UserData, LuaDataTypes::Thread,
    LuaDataTypes::Proto
};

// http://blog.codingnow.com/2015/05/lua_c_api.html


struct Lua
{
    lua_State* L;
    Lua( lua_State* L ) : L( L ) {}

    inline void OpenLibs()
    {
        luaL_openlibs( L );
    }
    inline bool DoFile( String const& fn )
    {
        return luaL_dofile( L, fn.C_str() ) == LUA_OK;
    }
    inline bool CheckStack( int n )
    {
        return lua_checkstack( L, n ) != 0;
    }
    inline bool DoString( String const& code )
    {
        return luaL_dostring( L, code.C_str() ) == LUA_OK;
    }
    inline void Push( lua_Number v )
    {
        lua_pushnumber( L, v );
    }
    inline void Push( lua_Integer v )
    {
        lua_pushinteger( L, v );
    }
    inline void Push( int v )
    {
        lua_pushinteger( L, v );
    }
    inline void Push( String const& v )
    {
        lua_pushlstring( L, v.C_str(), v.Size() );
    }
    inline void Push( char const* v )
    {
        lua_pushstring( L, v );
    }
    inline void Push( std::nullptr_t v )
    {
        lua_pushnil( L );
    }
    inline void PushNil()
    {
        lua_pushnil( L );
    }

    void PushMulti() {}

    template<typename T, typename...TS>
    void PushMulti( T const& p0, TS const&...parms )
    {
        Push( p0 );
        PushMulti( parms... );
    }

    inline void Pop( int n )
    {
        lua_pop( L, n );
    }
    inline int GetTop()
    {
        return lua_gettop( L );
    }
    inline void SetTop( int idx )
    {
        lua_settop( L, idx );
    }

    inline bool TopIs( int idx )
    {
        return GetTop() == idx;
    }
    inline LuaDataTypes GetType( int idx )
    {
        return map_lua_type_enums[ lua_type( L, idx ) + 1 ];
    }
    inline const char* GetTypeName( int idx )
    {
        return lua_typename( L, lua_type( L, idx ) );
    }
    inline bool IsInteger( int idx )
    {
        return lua_isinteger( L, idx ) == 1;
    }
    inline char const* ToCString( int idx )
    {
        return lua_tostring( L, idx );
    }
    inline String ToString( int idx, bool ref = false )
    {
        size_t len;
        auto rtv = lua_tolstring( L, idx, &len );
        return String( rtv, len, len, ref );
    }
    inline lua_Number ToNumber( int idx )
    {
        return lua_tonumber( L, idx );
    }
    inline lua_Integer ToInteger( int idx )
    {
        return lua_tointeger( L, idx );
    }

    inline void To( int32& v )
    {
        v = (int32)lua_tointeger( L, -1 );
    }
    inline void To( int64& v )
    {
        v = lua_tointeger( L, -1 );
    }
    inline void To( double& v )
    {
        v = lua_tonumber( L, -1 );
    }
    inline void To( String& v )
    {
        size_t len;
        auto rtv = lua_tolstring( L, -1, &len );
        v.Assign( rtv, len, false );
    }
    template<typename T, typename...TS>
    void ToMulti( T& p0, TS&...parms )
    {
        To( p0 );
        ToMulti( parms... );
    }

};

struct LuaEx : public Lua
{
    bool createrIsMe;
    String err;

    LuaEx()
        : Lua( luaL_newstate() )
        , createrIsMe( true )
    {
    }
    LuaEx( lua_State* L )
        : Lua( L )
        , createrIsMe( false )
    {
    }
    ~LuaEx()
    {
        if( createrIsMe )
        {
            lua_close( L );
        }
    }

    void ToErrPop()
    {
        size_t len = 0;
        err.Assign( lua_tolstring( L, -1, &len ), (int)len, false );
        lua_pop( L, 1 );
    }

    inline bool DoFile( String const& fn )
    {
        if( Lua::DoFile( fn ) ) return true;
        ToErrPop();
        return false;
    }

    inline bool DoString( String const& code )
    {
        if( Lua::DoString( code ) ) return true;
        ToErrPop();
        return false;
    }

    inline bool SafePush( lua_Number v )
    {
        if( !CheckStack( 1 ) ) return false;
        Push( v );
        return true;
    }
    inline bool SafePush( lua_Integer v )
    {
        if( !CheckStack( 1 ) ) return false;
        Push( v );
        return true;
    }
    inline bool SafePush( int v )
    {
        if( !CheckStack( 1 ) ) return false;
        Push( v );
        return true;
    }
    inline bool SafePush( String const& v )
    {
        if( !CheckStack( 1 ) ) return false;
        Push( v );
        return true;
    }
    inline bool SafePush( char const* v )
    {
        if( !CheckStack( 1 ) ) return false;
        Push( v );
        return true;
    }
    inline bool SafePushNil()
    {
        if( !CheckStack( 1 ) ) return false;
        PushNil();
        return true;
    }

    template<typename ...TS>
    int Pcall( String const& fn, TS const&...parms )
    {
        auto n = sizeof...( parms );
        if( !CheckStack( n + 1 ) ) return -1;
        int top = GetTop();
        if( lua_getglobal( L, fn.C_str() ) != LUA_TFUNCTION )   // stack +1: 1
        {
            Pop( 1 );                           // stack -1: 0
            err = "";
            return -1;
        }
        PushMulti( parms... );                                  // stack +n: 1+n
        if( lua_pcall( L, n, LUA_MULTRET, 0 ) != LUA_OK )       // stack -1-n: 0    T: stack +r: r    F: stack +e: e
        {
            ToErrPop();                        // stack -e: 0
            return -1;
        }
        return GetTop() - top;                                  // stack: r
    }

    template<typename ...TS>
    bool PcallPop( String const& fn, std::function<void( int n )> handler, TS const&...parms )
    {
        int rtv = Pcall( fn, parms... );
        if( rtv < 0 ) return false;
        if( handler ) handler( rtv );
        Pop( rtv );
        return true;
    }


    inline char const* ToCStringPop()
    {
        auto rtv = ToCString( -1 );
        Pop( 1 );
        return rtv;
    }
    inline String ToStringPop( bool ref = false )
    {
        auto rtv = ToString( -1, ref );
        Pop( 1 );
        return rtv;
    }
    inline lua_Number ToNumberPop()
    {
        auto rtv = ToNumber( -1 );
        Pop( 1 );
        return rtv;
    }
    inline lua_Integer ToIntegerPop()
    {
        auto rtv = ToInteger( -1 );
        Pop( 1 );
        return rtv;
    }


    template<typename T>
    static int __Index( lua_State* ls )
    {
        Lua L( ls );                                        // 2            // ud, key
        auto t = *(T**)lua_touserdata( ls, -2 );
        LuaGetterSetter<T>::GetField( L, *t );
        return 1;
    }
    template<typename T>
    static int __NewIndex( lua_State* ls )
    {
        Lua L( ls );                                        // 3            // ud, key£¬value
        auto t = *(T**)lua_touserdata( ls, -3 );
        LuaGetterSetter<T>::SetField( L, *t );
        return 0;
    }

    template<typename T>
    void Register( T* t, char const* typeName )
    {
        if( !LuaGetterSetter<T>::GetDict().Size() )
        {
            LuaGetterSetter<T>::Init();
        }
        static luaL_Reg reg[] =
        {
            // __gc
            { "__index", __Index < T > },
            { "__newindex", __NewIndex < T > },
            { nullptr, nullptr }
        };
        *(T**)lua_newuserdata( L, sizeof( T* ) ) = t;          // +1   1       // ud for store t
        if( luaL_newmetatable( L, typeName ) )                 // +1   2
        {
            luaL_setfuncs( L, reg, 0 );                        // -0   2       // bind funcs to metatable
        }
        lua_setmetatable( L, -2 );                             // -1   1       // bind metatable to ud
        lua_setglobal( L, typeName );                          // -1   0       // set ud to global
    }





    void Dump( int idx )
    {
        Cout( "data type = ", GetTypeName( idx ), "; value = " );
        switch( GetType( idx ) )
        {
        case LuaDataTypes::String:
            CoutLine( ToString( idx ) );
            break;
        case LuaDataTypes::Number:
            if( IsInteger( idx ) )
            {
                CoutLine( ToInteger( idx ) );
            }
            else
            {
                CoutLine( ToNumber( idx ) );
            }
            break;
        default:
            CoutLine( "{ to do }" );
        }
    }

    void DumpMulti( int n )
    {
        int top = GetTop();
        for( int i = top - n + 1; i <= top; ++i )
        {
            Dump( i );
        }
    }

    void DumpTop()
    {
        auto top = lua_gettop( L );
        Cout( "top = ", top, " " );
        if( top ) Dump( -1 );
        else CoutLine();
    };
};

template<typename T>
struct LuaGetterSetter {};

template<typename T>
struct LuaGetterSetterBase
{
    typedef std::function<void( Lua&, T& )> FuncType;
    static Dict < String, std::pair<FuncType, FuncType>>& GetDict()
    {
        static Dict < String, std::pair<FuncType, FuncType>> dict;
        return dict;
    }
    static void GetField( Lua& L, T& o )
    {
        auto& dict = GetDict();
        auto key = L.ToString( -1, true );
        if( auto node = dict.Find( key ) )
        {
            node->value.first( L, o );
        }
        else
        {
            L.PushNil();
        }
    }
    static void SetField( Lua& L, T& o )
    {
        auto& dict = GetDict();
        auto key = L.ToString( -2, true );
        if( auto node = dict.Find( key ) )
        {
            node->value.second( L, o );
        }
    }
    static void Register( char const* key, FuncType getter, FuncType setter )
    {
        auto& dict = GetDict();
        dict.Insert( key, std::make_pair( getter, setter ) );
    }

    template<typename FT>
    static void Register( char const* key, FT T::* fieldOffset )
    {
        GetDict().Insert( key, std::make_pair( 
        [ fieldOffset ]( Lua& L, T& o ) { 
            L.Push( o.*fieldOffset );
        }, [ fieldOffset ]( Lua& L, T& o ) { 
            L.To( o.*fieldOffset );
        } ) );
    }
};

struct Foo1
{
    int x = 0;
    int y = 0;
};
struct Foo2
{
    String x;
};
template<> struct LuaGetterSetter < Foo1 > : LuaGetterSetterBase < Foo1 >
{
    inline static void Init()
    {
        Register( "x", &Foo1::x );
        Register( "y", &Foo1::y );
    }
};
template<> struct LuaGetterSetter < Foo2 > : LuaGetterSetterBase < Foo2 >
{
    inline static void Init()
    {
        Register( "x", &Foo2::x );
    }
};
int main()
{
    LuaEx L;
    L.OpenLibs();
    Foo1 f1; Foo2 f2;
    L.Register( &f1, "Foo1" );
    L.Register( &f2, "Foo2" );
    L.DoString( R"--(
function f1( x, y, name )
    Foo1.x = x
    Foo1.y = y
    Foo2.x = name
end
function f2()
    return Foo1.x, Foo1.y, Foo2.x
end
)--" );
    L.PcallPop( "f1", nullptr, 12, 34, "asdfqwer" );
    L.PcallPop( "f2", [ &]( int n ) { L.DumpMulti( n ); } );
    CoutLine( "f1.x, f1.y, f2.x = ", f1.x, " ", f1.y, " ", f2.x );
    system( "pause" );
    return 0;
}

//function xxx( ... )
//    print( 1 )
//    local t = {...}
//    print( 2 )
//    table.insert( t, "asdf" )
//    table.insert( t, 12 )
//    table.insert( t, 34.5 )
//    print( 3 )
//    return table.unpack( t ) 
//end





















// ÈËÆøÍøÓÎ¡¶Ä§ÊÞÊÀ½ç¡·¹²ÓÐ10¸öÖ°Òµ£ºÕ½Ê¿¡¢ËÀÍöÆïÊ¿¡¢Ê¥ÆïÊ¿¡¢µÂÂ³ÒÁ¡¢ÈøÂú¡¢ÄÁÊ¦¡¢·¨Ê¦¡¢Ç±ÐÐÕß¡¢ÁÔÈË¡¢¡¢ÊõÊ¿¡£ÆäÖÐ£¬Õ½Ê¿¡¢ËÀÍöÆïÊ¿¡¢Ê¥ÆïÊ¿¡¢µÂÂ³ÒÁ¿ÉÒÔ×öÌ¹¿Ë£¬Ê¥ÆïÊ¿¡¢µÂÂ³ÒÁ¡¢ÈøÂúºÍÄÁÊ¦¿ÉÒÔÖÎÁÆ£¬ËùÓÐµÄÖ°Òµ¶¼¿ÉÒÔÊä³ö¡£ÏÖ×éÒ»¸ö5ÈË¶ÓÎéÈ¥ÏÂ¸±±¾£¬ÒªÇó1Ì¹¿Ë¡¢1ÖÎÁÆºÍ3Êä³ö£¬ÎÊ×Ü¹²ÄÜ×é³É¶àÉÙÖÖ²»Í¬µÄ¶ÓÎé£¿

int main()
{
    // T: 0 Õ½Ê¿  1 ËÀÍöÆïÊ¿  2 Ê¥ÆïÊ¿  3 µÂÂ³ÒÁ
    // N: 4 ÈøÂú  5 ÄÁÊ¦    23

    // µÃµ½ËùÓÐÅÅÁÐ£¨È¥ÖØµÄ£©
    set<string> ss;
    for( int i = 0; i <= 99999; ++i )
    {
        char buf[ 6 ];
        sprintf( buf, "%05d", i );
        std::sort( buf, buf + 5 );
        ss.insert( buf );
    }

    set<string> result;

    // Æ¥ÅäÉ¨Ãè1: ÏÈ³éT
    for( auto& s : ss )
    {
        auto tmp = s;
        // ³éµô 1T
        for( auto it = tmp.cbegin(); it != tmp.cend(); it++ )
        {
            if( *it >= '0' && *it <= '3' )
            {
                tmp.erase( it );
                break;
            }
        }
        if( tmp.size() == 5 ) continue;

        // ³éµô 1ÄÌ
        for( auto it = tmp.cbegin(); it != tmp.cend(); it++ )
        {
            if( *it >= '2' && *it <= '5' )
            {
                tmp.erase( it );
                break;
            }
        }
        if( tmp.size() == 4 ) continue;

        // Ê£ÈýÈË£¬³É¹¦Æ¥Åä
        result.insert( s );
    }

    // Æ¥ÅäÉ¨Ãè2: ÏÈ³éÄÌ
    for( auto& s : ss )
    {
        auto tmp = s;
        // ³éµô 1ÄÌ
        for( auto it = tmp.cbegin(); it != tmp.cend(); it++ )
        {
            if( *it >= '2' && *it <= '5' )
            {
                tmp.erase( it );
                break;
            }
        }
        if( tmp.size() == 5 ) continue;

        // ³éµô 1T
        for( auto it = tmp.cbegin(); it != tmp.cend(); it++ )
        {
            if( *it >= '0' && *it <= '3' )
            {
                tmp.erase( it );
                break;
            }
        }
        if( tmp.size() == 4 ) continue;

        // Ê£ÈýÈË£¬³É¹¦Æ¥Åä
        result.insert( s );
    }
    cout << result.size() << endl;



















class Foo
{
public:
    Foo* parent = nullptr;
    List<Foo*> childs;

    // ByteBuffer interface
    inline void WriteTo( ByteBuffer& bb ) const
    {
        bb.WriteMulti( this->parent, this->childs );
    }
    inline bool ReadFrom( ByteBuffer& bb )
    {
        return bb.ReadMulti( this->parent, this->childs );
    }
};

int main()
{
    ByteBuffer bb;
    {
        List<bool> bs;
        bs.Push( true );
        bs.Push( false );
        bs.Push( false );
        bs.Push( false );
        bs.Push( true );
        bs.Push( false );
        bs.Push( false );
        bs.Push( false );
        bs.Push( true );
        bs.Push( false );
        bs.Push( false );
        bs.Push( false );

        bb.Write( bs );
        CoutLine( bb.Dump() );
    }
    {
        List<bool> bs;
        bb.Read( bs );
        for( int i = 0; i < bs.Size(); ++i )
        {
            CoutLine( bs[ i ] ? "true " : "false " );
        }
    }
    return 0;

    {
        Foo f;
        f.parent = &f;
        f.childs.Push( &f );
        f.childs.Push( &f );
        f.childs.Push( &f );

        bb.RootWrite( f );
        CoutLine( bb.Dump() );
    }

    {
        Foo f;
        if( bb.RootRead( f ) )
        {
            CoutLine( (uint64)f.parent );
            for( auto i = 0; i < f.childs.Size(); ++i )
            {
                CoutLine( (uint64)f.childs[ i ] );
            }
        }
    }

    return 0;
}



//
//
//class Bar
//{
//public:
//    int a = 1;
//    int b = 2;
//
//    // ByteBuffer interface
//    inline void WriteTo( ByteBuffer& bb ) const
//    {
//        bb.VarWrite( a );
//        bb.VarWrite( b );
//    }
//
//    inline bool ReadFrom( ByteBuffer& bb )
//    {
//        if( !bb.VarRead( a ) ) return false;
//        if( !bb.VarRead( b ) ) return false;
//        return true;
//    }
//};
//
//
//int main()
//{
//    ByteBuffer bb;
//    {
//        Bar b;
//        b.a = 3;
//        b.b = 4;
//        bb.Write( b );
//        CoutLine( bb.Dump() );
//    }
//    {
//        Bar b;
//        if( bb.Read( b ) )
//        {
//            CoutLine( "b.a = ", b.a, ", b.b = ", b.b );
//        }
//    }
//    
//    return 0;
//}

	
	
	
	
	
	
	
	
	
	
	
	List<void*> ps;
    int c16 = 0, c32 = 0, c8 = 0, c4 = 0, c64 = 0;
    for( int i = 0; i < 9999999; ++i )
    {
        auto p = (size_t)( void* )new char();
        if( (p & 63 ) == 0 ) c64++;
        else if( ( p & 31 ) == 0 ) c32++;
        else if( ( p & 15 ) == 0 ) c16++;
        else if( ( p & 7 ) == 0 ) c8++;
        else if( ( p & 3 ) == 0 ) c4++;
        ps.Push( (void*)p );
    }
    CoutLine( c64, " ", c32, " ", c16, " ", c8, " ", c4 );


    std::unordered_map<void*, int> map;
    Dict<void*, int> dict;
    dict.Reserve( 9999999 );
    Stopwatch sw;
    for( int i = 0; i < 9999999; ++i )
    {
        map.insert( std::make_pair( ps[ i ], i ) );
    }
    CoutLine( "map insert ms = ", sw.ElapsedMillseconds() );
    sw.Reset();
    for( int i = 0; i < 9999999; ++i )
    {
        dict.Insert( ps[ i ], i );
    }
    CoutLine( "dict insert ms = ", sw.ElapsedMillseconds() );












	
int main()
{
/*
    ByteBuffer bb;
    Foo f{ 123, 4.5, 6.7f, "asdfqw", { 1, 2, 3, 4, 5 } };
    Stopwatch sw;
    for( int i = 0; i < 100000000; ++i )
    {
        bb.Clear();
        bb.Write( f );
    }
    Cout( sw.ElapsedMillseconds() );
    CoutLine( bb.Dump() );

    Foo f2;
    f2.ReadFrom( bb );

    CoutLine( f2.i, " ", f2.d, " ", f2.f, " ", f2.s );
    for( int i = 0; i < f2.ss.Size(); ++i ) Cout( i ? "," : "", f2.ss[ i ] );
    CoutLine();

    return 0;
    */
}




int main()
{
    ByteBuffer bb;
    Stopwatch sw;
    for( int i = 0; i < 999999999; ++i )
    {
        //bb.Clear();
        //bb.FastWriteMulti( (ushort)12345, (byte)67, "asdf", 0.12f );
    }
    Cout( sw.ElapsedMillseconds() );
    Cout( bb.Dump() );
    return 0;
}


















#include "Lib/All.h"
using namespace std;
using namespace xxx;

struct Buf_MaxHP_Enhance100Percent;
struct Buf_MaxHP_Enhance10Point;
struct Dot_HP_Recover1PointPerTicks;

struct Foo
{
    // Ô­ÐÍÏµÁÐ( ÀíÂÛÉÏ½²´æÔÚÒ»¸öÔ­ÐÍÀà )
    int ori_maxHP;                  // Ô­Ê¼×î´óÑªÁ¿
    float ori_maxHPMultiple;        // Ô­Ê¼×î´óÑªÁ¿°Ù·Ö±È buf Öµ
    int ori_maxHPIncrease;          // Ô­Ê¼×î´óÑªÁ¿µãÊý buf Öµ
    int ori_HP;

    // µ±Ç°ÏµÁÐ( Ô­Ê¼ÖµÓë buf ÏµÊý )
    int cur_maxHP;
    float cur_maxHPMultiple;
    int cur_maxHPIncrease;
    int cur_HP;

    // buf ºóÏµÁÐ
    int buf_maxHP;

    // Process ºóÐèÒªÒÀ´ÎÖ´ÐÐµÄº¯Êý, Ö´ÐÐÍêºó clear
    List<std::function<void()>> funcs;

    // ³õÊ¼»¯Ô­ÐÍÊý¾Ý
    inline void InitOriginal()
    {
        ori_maxHP = 100;
        ori_maxHPMultiple = 1;
        ori_maxHPIncrease = 0;
        ori_HP = 50;
    }

    inline void InitCurrent()
    {
        cur_maxHP = ori_maxHP;
        cur_HP = ori_HP;
    }

    // Îª¼ÆËã buf ¶øÖØÖÃ buf ÏµÊý
    inline void ResetBufProperties()
    {
        cur_maxHPMultiple = ori_maxHPMultiple;
        cur_maxHPIncrease = ori_maxHPIncrease;
    }

    // ËãÊÜ buf Ó°ÏìµÄÊôÐÔ( ÓÅÏÈ¼¶¹«Ê½ÔÚ´Ë )
    inline void CalcBufProperties()
    {
        buf_maxHP = int( ori_maxHP * cur_maxHPMultiple ) + cur_maxHPIncrease;
    }

    inline void CallFuncs()
    {
        for( int i = 0; i < funcs.Size(); ++i )
        {
            funcs[ i ]();
        }
        funcs.Clear();
    }

    // ×ÛºÏ³õÊ¼»¯
    inline void Init()
    {
        InitOriginal();
        InitCurrent();
        ResetBufProperties();
    }

    BufContainer bc;
    Foo( BufPool<BufBase>* bp )
        : bc( bp )
    {
        bc.BeforeBufProcess = [ this ] { ResetBufProperties(); };
        bc.AfterBufProcess = [ this ] { CalcBufProperties(); };
        Init();
    }

    inline void Process( int ticks )
    {
        bc.Process( ticks );
        // todo: foreach call funcs
    }

    void CreateBuf_×î´óÑªÁ¿¼Ó10µã( int ticks, int life );
    void CreateBuf_×î´óÑªÁ¿¼Ó°Ù·ÖÖ®100( int ticks, int life );
    void CreateDot_ÑªÁ¿»Ö¸´1µã( int ticks, int cd );
};

struct Buf_MaxHP_Enhance100Percent : Buf<Buf_MaxHP_Enhance100Percent>
{
    Foo* owner;
    inline void Init( Foo* owner, int ticks, int life )
    {
        this->owner = owner;
        this->activeTicks = ticks + life;
    }
    inline bool Process( int ticks ) override
    {
        owner->cur_maxHPMultiple += 1;
        return true;
    }
};

struct Buf_MaxHP_Enhance10Point : Buf<Buf_MaxHP_Enhance10Point>
{
    Foo* owner;
    inline void Init( Foo* owner, int ticks, int life )
    {
        this->owner = owner;
        this->activeTicks = ticks + life;
    }
    inline bool Process( int ticks ) override
    {
        owner->cur_maxHPIncrease += 10;
        return true;
    }
};

struct Dot_HP_Recover1PointPerTicks : Buf<Dot_HP_Recover1PointPerTicks>
{
    Foo* owner;
    int cd;
    inline void Init( Foo* owner, int ticks, int cd )
    {
        this->owner = owner;
        this->activeTicks = ticks + cd;
        this->cd = cd;
    }
    inline bool Process( int ticks ) override
    {
        // ÀíÂÛÉÏ½²£¬²»ÉÙ dot ÐèÒªÒÔÕâÖÖ·½Ê½À´ÔË×÷: owner->funcs.Push( .... )
        // ¼´Ïàµ±ÓÚ°ÑÊÂÇé·Åµ½ Process Ö®ºóÀ´×ö. 
        // Ö´ÐÐ¹ý³ÌÖÐ£¬ÓÐ¿ÉÄÜÄ¿±êÒÑËÀÉ¶µÄ£¬¶¼ÐèÒª×öÏàÓ¦´¦Àí
        owner->cur_HP += 1;
        if( owner->cur_HP > owner->buf_maxHP )
        {
            owner->cur_HP = owner->buf_maxHP;
        }
        activeTicks = ticks + cd;
        //Cout( "owner->cur_HP = ", owner->cur_HP );
        return true;
    }
};

void Foo::CreateBuf_×î´óÑªÁ¿¼Ó10µã( int ticks, int life )
{
    bc.CreateBuf<Buf_MaxHP_Enhance10Point>( this, ticks, life );
}
void Foo::CreateBuf_×î´óÑªÁ¿¼Ó°Ù·ÖÖ®100( int ticks, int life )
{
    bc.CreateBuf<Buf_MaxHP_Enhance100Percent>( this, ticks, life );
}
void Foo::CreateDot_ÑªÁ¿»Ö¸´1µã( int ticks, int cd )
{
    bc.CreateDot<Dot_HP_Recover1PointPerTicks>( this, ticks, cd );
}


typedef xxx::Singleton<BufPool<BufBase>> FooBufPool;
int main()
{
    FooBufPool::InitInstance();

    Stopwatch sw;
    for( int j = 0; j < 10000000; ++j )
    {
        Foo foo( FooBufPool::GetInstance() );

        // ·ÂÒ»¸öÖ¡²½½øÖµ
        int ticks = 123;

        // À´¼¸¸ö buf( ¼Ó ÑªÉÏÏÞ °Ù·Ö±ÈºÍµãÊý, ´æ»îÊ±³¤²»Í¬ )
        foo.CreateBuf_×î´óÑªÁ¿¼Ó10µã( ticks, 10 );
        foo.CreateBuf_×î´óÑªÁ¿¼Ó°Ù·ÖÖ®100( ticks, 9 );
        foo.CreateBuf_×î´óÑªÁ¿¼Ó10µã( ticks, 8 );
        foo.CreateBuf_×î´óÑªÁ¿¼Ó°Ù·ÖÖ®100( ticks, 7 );
        foo.CreateBuf_×î´óÑªÁ¿¼Ó10µã( ticks, 6 );

        // À´¼¸¸ö dot( ²»¶ÏµÄ»Ö¸´Ñª, Ã¿Ìø¼ä¸ôÊ±³¤²»Í¬ )
        foo.CreateDot_ÑªÁ¿»Ö¸´1µã( ticks, 1 );
        foo.CreateDot_ÑªÁ¿»Ö¸´1µã( ticks, 2 );
        foo.CreateDot_ÑªÁ¿»Ö¸´1µã( ticks, 3 );

        for( int i = 0; i < 11; ++i )
        {
            ticks++;
            foo.Process( ticks );
            //Cout( "buf_maxHP = ", foo.buf_maxHP, ", cur_HP = ", foo.cur_HP );
        }
    }
    Cout( "ms = ", sw.ElapsedMillseconds() );

    Cout( "FooBufPool::GetInstance()->data[ 0 ].Size() = ", FooBufPool::GetInstance()->data[ 0 ].Size() );
    Cout( "FooBufPool::GetInstance()->data[ 1 ].Size() = ", FooBufPool::GetInstance()->data[ 1 ].Size() );
    Cout( "FooBufPool::GetInstance()->data[ 2 ].Size() = ", FooBufPool::GetInstance()->data[ 2 ].Size() );

    system( "pause" );
    return 0;
}



























#include "Lib/All.h"
using namespace std;
using namespace xxx;


//class X : Singleton < X >
//{
//public:
//    int( *func1 )( int a, int b );
//    int( *func2 )( int a, int b );
//
//    // ...
//
//    HINSTANCE dll = nullptr;
//    X()
//    {
//        if( dll = LoadLibrary( L"MyDll.dll" ) )
//        {
//            func1 = (decltype( func1 ))GetProcAddress( dll, "func1" );
//            func2 = (decltype( func2 ))GetProcAddress( dll, "func2" );
//            // ...
//        }
//    }
//    ~X()
//    {
//        if( dll ) FreeLibrary( dll );
//    }
//}


struct Foo
{
    explicit Foo( int n ) { Cout( n ); }
};

int main()
{
    Nullable<Foo> f;
    Cout( f.HasValue() );
    f.Emplace( 123 );
    Cout( f.HasValue() );
    f.Clear();
    Cout( f.HasValue() );

    system( "pause" );
    return 0;
}



























#include "Lib/All.h"
using namespace std;
using namespace xxx;

#include "Nullable.h"

struct Foo;

struct FooStateBase : public CorCore
{
    Foo* owner;
};
struct FooState1 : public FooStateBase
{
    String name;
    void Init( Foo* _owner, String const& _name /* , ... */ );
    bool Process( int _ticks ) override;
    void Destroy() override;
};
struct FooState2 : public FooStateBase
{
    String name;
    void Init( Foo* _owner, String const& _name /* , ... */ );
    bool Process( int _ticks ) override;
    void Destroy() override;
};
struct Foo : public CorBase < Foo >
{
    std::aligned_storage_t < MaxSize<
        FooState1, FooState2 /* , ... */
    >::value, 8 > stateData[ 1 ];
    FooStateBase* state = (FooStateBase*)stateData;
    String name;
    void Init( String const& _name );
    bool Process( int _ticks ) override;
};



void FooState1::Init( Foo* _owner, String const& _name )
{
    new ( this ) FooState1();
    owner = _owner;
    // ...
    name = _name;
    Cout( name, " Init ed" );
}
bool FooState1::Process( int _ticks )
{
    COR_BEGIN;
    Cout( name, " Process: before sleep( 2 )" );
    COR_SLEEP( 2 );
    Cout( name, " Process: sleeped" );
    COR_END;
}
void FooState1::Destroy()
{
    Cout( name, " Destroy ing" );
    // ...
    auto o = owner;
    String fs2Name;
    fs2Name.Append( o->name, "'s FS2" );
    FooState1::~FooState1();
    ( (FooState2*)o->state )->Init( o, std::move( fs2Name ) );
}

void FooState2::Init( Foo* _owner, String const& _name )
{
    new ( this )FooState2();
    owner = _owner;
    // ...
    name = _name;
    Cout( name, " Init ed" );
}
bool FooState2::Process( int _ticks )
{
    COR_BEGIN;
    Cout( name, " Process: before sleep( 4 )" );
    COR_SLEEP( 4 );
    Cout( name, " Process: sleeped" );
    COR_END;
}
void FooState2::Destroy()
{
    Cout( name, " Destroy ing" );
    // ...
    auto o = owner;
    FooState2::~FooState2();
    o->state = nullptr;
}



void Foo::Init( String const& _name )
{
    name = _name;
    auto stateName = name;
    stateName.Append( "'s FS1" );
    ( (FooState1*)state )->Init( this, stateName );
}

bool Foo::Process( int _ticks )
{
    if( state->Process( _ticks ) ) return true;
    state->Destroy();
    return state != nullptr;
}





int main()
{
    CorManager<Cor> cm;
    cm.CreateItem<Foo>( "Foo1" );
    cm.CreateItem<Foo>( "Foo2" );
    cm.CreateItem<Foo>( "Foo3" );
    int i = 0;
    do
    {
        Cout( "step: ", ++i );
    } while( cm.Process( i ) );

    system( "pause" );
    return 0;
}





















#include "Lib/All.h"
using namespace std;
using namespace xxx;


template<typename T>
struct StateBase : CorCore
{
    T* owner = nullptr;
};

template<typename T>
struct DieState : public StateBase < T >
{
    DieState( T* _owner );
    void Init();   // todo: more parms
    bool Process( int _ticks ) override;
    void Destroy() override;
};

template<typename T>
struct LiveState : public StateBase < T >
{
    LiveState( T* _owner );
    void Init();   // todo: more parms
    bool Process( int _ticks ) override;
    void Destroy() override;
};

template<typename T>
struct BornState : public StateBase < T >
{
    BornState( T* _owner );
    void Init();   // todo: more parms
    bool Process( int _ticks ) override;
    void Destroy() override;
};


struct Foo : public CorBase < Foo >
{
    BornState<Foo>          bornState;
    LiveState<Foo>          liveState;
    DieState<Foo>           dieState;
    StateBase<Foo>*         currState = nullptr;
    std::function<void()>   changeState;
    Foo();
    void Init();
    bool Process( int _ticks ) override;
};









Foo::Foo()
    : bornState( this )
    , liveState( this )
    , dieState( this )
{
}

void Foo::Init()
{
    changeState = [ this ] { bornState.Init(); };
}

bool Foo::Process( int _ticks )
{
    if( currState )
    {
        if( currState->Process( _ticks ) ) return true;
        currState->Destroy();
        currState = nullptr;
    }
    if( changeState ) changeState();
    if( currState ) return true;
    return false;
}




template<typename T>
BornState<T>::BornState( T* _owner )
{
    owner = _owner;
}

template<typename T>
void BornState<T>::Init()
{
    owner->currState = this;
    Cout( "born begin" );
}

template<typename T>
bool BornState<T>::Process( int _ticks )
{
    COR_BEGIN;
    Cout( "born ing..." );
    COR_SLEEP( 1 );
    auto _owner = owner;
    owner->changeState = [ _owner ] { _owner->liveState.Init(); };
    COR_END;
}

template<typename T>
void BornState<T>::Destroy()
{
    Cout( "born end" );
}



template<typename T>
LiveState<T>::LiveState( T* _owner )
{
    owner = _owner;
}

template<typename T>
void LiveState<T>::Init()
{
    owner->currState = this;
    Cout( "live begin" );
}

template<typename T>
bool LiveState<T>::Process( int _ticks )
{
    COR_BEGIN;
    Cout( "live ing..." );
    COR_SLEEP( 2 );
    auto _owner = owner;
    owner->changeState = [ _owner ] { _owner->dieState.Init(); };
    COR_END;
}

template<typename T>
void LiveState<T>::Destroy()
{
    Cout( "live end" );
}




template<typename T>
DieState<T>::DieState( T* _owner )
{
    owner = _owner;
}

template<typename T>
void DieState<T>::Init()
{
    owner->currState = this;
    Cout( "die begin" );
}

template<typename T>
bool DieState<T>::Process( int _ticks )
{
    COR_BEGIN;
    Cout( "die ing..." );
    COR_SLEEP( 3 );
    owner->changeState = nullptr;
    COR_END;
}

template<typename T>
void DieState<T>::Destroy()
{
    Cout( "die end" );
}



int main()
{
    CorManager<Cor> cm;
    cm.CreateItem<Foo>();
    int i = 0;
    do
    {
        Cout( "step: ", ++i );
    } while( cm.Process( i ) );

    system( "pause" );
    return 0;
}
























#include "Lib/All.h"
using namespace std;
using namespace xxx;


struct Bar : public CorBase<Bar>
{
    String txt;
    void Init( String _txt )
    {
        txt = _txt;
    }
    bool Process( int _ticks ) override
    {
        COR_BEGIN;
        Cout( txt, " say: i'm living..." );
        COR_SLEEP( 5 );
        Cout( txt, " say: i'm dieing..." );
        COR_END;
    }
};

struct Foo : public CorBase<Foo>
{
    REF_DECL( Bar, bar );

    void Init( Bar* _bar )
    {
        REF_SET( bar, _bar );
    }
    void EnsureRefs() override
    {
        REF_ENSURE( bar );
    }

    int i;
    bool Process( int _ticks ) override
    {
        EnsureRefs();
        COR_BEGIN;
        for( i = 0; i < 9; ++i )
        {
            Cout( "Foo's i = ", i );
            if( bar )
            {
                Cout( "Foo's Bar alive!" );
            }
            COR_YIELD;
        }
        COR_END;
    }
};

int main()
{
    CorManager<Cor> fbm;
    fbm.CreateItem<Foo>( fbm.CreateItem<Bar>( "Bar" ) );
    while( fbm.Process() );

    system( "pause" );
    return 0;
}






















#include <iostream>
#include <vector>
#include <functional>
#include <array>
#include <memory>
#include <cassert>
#include <list>
#include "Lib/All.h"
using namespace std;

struct StdFoo
{
    list<StdFoo*>::iterator it;
};

struct MyFoo
{
    Links<MyFoo*>::Node* it;
};

int main()
{
    vector<StdFoo*> stdfoos;
    stdfoos.reserve( 9999999 );
    vector<MyFoo*> myfoos;
    myfoos.reserve( 9999999 );

    for( int x = 0; x < 10; ++x )
    {

        {
            int count = 0;
            list<StdFoo*> c;
            Stopwatch sw;
            for( int i = 0; i < 9999999; ++i )
            {
                auto foo = new StdFoo();
                stdfoos.push_back( foo );
                c.push_back( foo );
                foo->it = --c.end();
            }
            Cout( "std::list pus_back ms: ", sw.elapsedMillseconds() );
            Cout( c.size() );

            sw.reset();
            for( int i = 0; i < 9999999; ++i )
            {
                c.erase( stdfoos[ i ]->it );
                delete stdfoos[ i ];
            }
            Cout( "std::list erase ms: ", sw.elapsedMillseconds() );

            stdfoos.clear();
        }

        {
            int count = 0;
            set<StdFoo*> c;
            Stopwatch sw;
            for( int i = 0; i < 9999999; ++i )
            {
                auto foo = new StdFoo();
                stdfoos.push_back( foo );
                c.insert( foo );
            }
            Cout( "std::set insert ms: ", sw.elapsedMillseconds() );
            Cout( c.size() );

            sw.reset();
            for( int i = 0; i < 9999999; ++i )
            {
                c.erase( stdfoos[ i ] );
                delete stdfoos[ i ];
            }
            Cout( "std::set erase ms: ", sw.elapsedMillseconds() );

            stdfoos.clear();
        }

        {
            int count = 0;
            Links<MyFoo*> c;
            Stopwatch sw;
            for( int i = 0; i < 9999999; ++i )
            {
                auto foo = new MyFoo();
                myfoos.push_back( foo );
                foo->it = c.insert( foo );
            }
            Cout( "Links pus_back ms: ", sw.elapsedMillseconds() );
            Cout( c.size() );

            sw.reset();
            for( int i = 0; i < 9999999; ++i )
            {
                c.erase( myfoos[ i ]->it );
                delete myfoos[ i ];
            }
            Cout( "Links erase ms: ", sw.elapsedMillseconds() );

            myfoos.clear();
        }

        {
            int count = 0;
            Hash<MyFoo*> c;
            Stopwatch sw;
            for( int i = 0; i < 9999999; ++i )
            {
                auto foo = new MyFoo();
                myfoos.push_back( foo );
                c.insert( foo );
            }
            Cout( "Hash pus_back ms: ", sw.elapsedMillseconds() );
            Cout( c.size() );

            sw.reset();
            for( int i = 0; i < 9999999; ++i )
            {
                c.erase( myfoos[ i ] );
                delete myfoos[ i ];
            }
            Cout( "Hash erase ms: ", sw.elapsedMillseconds() );

            myfoos.clear();
        }

        Cout( "\n\n" );
    }

    //int count;
    //for( int x = 0; x < 10; ++x )
    //{
    //    {
    //        list<int> c;
    //        Stopwatch sw;
    //        for( int i = 0; i < 9999999; ++i )
    //        {
    //            c.push_back( i );
    //        }
    //        Cout( "std::list pus_back ms: ", sw.elapsedMillseconds() );
    //        Cout( c.size() );

    //        count = 0;
    //        sw.reset();
    //        for( auto i : c ) count += i;
    //        Cout( "std::list foreach ms: ", sw.elapsedMillseconds() );
    //        Cout( count );

    //        count = 0;
    //        sw.reset();
    //        for( int i = 0; i < 99999; ++i )
    //        {
    //            auto it = find( c.begin(), c.end(), i );
    //            if( it != c.end() )
    //            {
    //                count += ( *it );
    //            }
    //        }
    //        Cout( "std::list find ms: ", sw.elapsedMillseconds() );
    //        Cout( count );

    //        vector<decltype( c.begin() )> its;
    //        for( auto it = c.begin(); it != c.end(); ++it ) its.push_back( it );
    //        sw.reset();
    //        for( auto it : its ) c.erase( it );
    //        Cout( "std::list erase ms: ", sw.elapsedMillseconds() );
    //        Cout( count );
    //    }

    //    count = 0;
    //    {
    //        Links<int> c;
    //        Stopwatch sw;
    //        for( int i = 0; i < 9999999; ++i )
    //        {
    //            c.insert( i );
    //        }
    //        Cout( "Links insert ms: ", sw.elapsedMillseconds() );
    //        Cout( c.size() );

    //        count = 0;
    //        sw.reset();
    //        for( int i = 0; i < 9999999; ++i ) count += c[ i ]->value;
    //        Cout( "Links foreach ms: ", sw.elapsedMillseconds() );
    //        Cout( count );

    //        count = 0;
    //        sw.reset();
    //        for( int i = 0; i < 99999; ++i )
    //        {
    //            auto it = c.find( i );
    //            if( it ) count += it->value;
    //        }
    //        Cout( "Links find ms: ", sw.elapsedMillseconds() );
    //        Cout( count );

    //        vector<decltype( c.insert( 0 ) )> its;
    //        for( int i = 0; i < 9999999; ++i ) its.push_back( c[ i ] );
    //        sw.reset();
    //        for( auto it : its ) c.erase( it );
    //        Cout( "Links erase ms: ", sw.elapsedMillseconds() );
    //        Cout( count );
    //    }

    //    Cout( "\n\n" );
    //}

    system( "pause" );
    return 0;
}

















#include <iostream>
#include <vector>
#include <functional>
#include <array>
#include <memory>
#include <cassert>
#include "Lib/All.h"
using namespace std;

int main()
{
    {
        set<int> sss;
        Stopwatch sw;
        for( int i = 55; i < 9999999; ++i )
        {
            auto oldval = ( i - 55 ) % 99;
            auto newval = i % 99;
            sss.erase( oldval );
            sss.insert( newval );
        }
        Cout( sw.elapsedMillseconds() );
        Cout( sss.size() );
    }

    {
        vector<int> vvv;
        Stopwatch sw;
        for( int i = 55; i < 9999999; ++i )
        {
            auto oldval = ( i - 55 ) % 99;
            auto newval = i % 99;
            //vvv.erase( oldval );
            auto it = find( vvv.begin(), vvv.end(), oldval );
            if( it != vvv.end() ) vvv.erase( it );
            vvv.push_back( newval );
        }
        Cout( sw.elapsedMillseconds() );
        Cout( vvv.size() );
    }

    {
        Set<int> sss;
        Stopwatch sw;
        for( int i = 55; i < 9999999; ++i )
        {
            auto oldval = ( i - 55 ) % 99;
            auto newval = i % 99;
            sss.erase( oldval );
            sss.insert( newval );
        }
        Cout( sw.elapsedMillseconds() );
        Cout( sss.size() );
    }


    //Set<int> myset;
    //{
    //    Stopwatch sw;
    //    myset.reserve( 9999999 );
    //    for( int i = 0; i < 9999999; ++i )
    //    {
    //        myset.insert( i );
    //    }
    //    Cout( sw.elapsedMillseconds() );
    //    Cout( myset.size() );

    //    sw.reset();
    //    for( int i = 0; i < 9999999; ++i )
    //    {
    //        myset.erase( i );
    //    }
    //    Cout( sw.elapsedMillseconds() );
    //    Cout( myset.size() );
    //}


    system( "pause" );
    return 0;
}





































#include <iostream>
#include <vector>
#include <functional>
#include <array>
#include <memory>
#include <cassert>
using namespace std;

typedef function<void()> StepTimerItemType;
struct StepTimerItemHandlerType
{
    inline static void handle( StepTimerItemType& o )
    {
        o();
    }
};

template<int len, typename T = StepTimerItemType, typename HT = StepTimerItemHandlerType>
class StepTimer
{
public:
    explicit StepTimer( int n = 0 ) : _counter( n ) {}
    void update( int elapsed = 1 )
    {
        for( int i = 0; i < elapsed; ++i )
        {
            auto& os = _oss[ ( _counter + i ) % len ];
            for( int i = 0; i < (int)os.size(); ++i ) HT::handle( os[ i ] );
            os.clear();
        }
        _counter += elapsed;
    }
    template<typename VT>
    void insert( int n, VT&& v )
    {
        assert( n > 0 && n < len );
        _oss[ ( _counter + n ) % len ].push_back( std::forward<VT>( v ) );
    }
    void clear()
    {
        for( auto& os : _oss ) os.clear();
        _counter = 0;
    }
private:
    int _counter;
    vector<T> _oss[ len ];
};

struct EEE
{
    void xxx()
    {
        //cout << "eee";
    }
};


struct FooBase
{
    function<void()> _timerCallback;
};

struct FooBaseTimerCallbackHandler
{
    inline static void handle( weak_ptr<FooBase>& o )
    {
        if( auto p = o.lock() )
            p->_timerCallback();
    }
};




struct Foo : public FooBase
{
};


int main()
{
    int n = 0;
    StepTimer<999, weak_ptr<FooBase>, FooBaseTimerCallbackHandler> t( n );
    int _counter = 0;
    vector<shared_ptr<Foo>> _foos;
    for( int i = 0; i < 1000; ++i )
    {
        auto f = make_shared<Foo>();
        auto wf = weak_ptr<Foo>( f );
        f->_timerCallback = [&t, &_counter, wf]
        {
            _counter++;
            t.insert( 1, wf );
        };
        t.insert( 1, wf );
        _foos.push_back( f );
    }

//    Stopwatch sw;
    while( n < 10000 )
    {
        t.update();
        //if( n == 1000 )
        //{
        //    for( auto& f : _foos ) f.reset();
        //}
        ++n;
    }
//    Cout( sw.elapsedMillseconds() );
    cout << "\nn = " << n << ", counter = " << _counter;

    system( "pause" );
    return 0;
}









































// todo

class HashString : Memmoveable
{
public:
    HashString( String const& s )
    {
        _s = s;
        _h = _s.getHashCode();
    }
    HashString( String && s )
    {
        _s = std::move( s );
        _h = _s.getHashCode();
    }
    HashString( HashString const& other )
        : _s( other._s )
        , _h( other._h )
    {
    }
    HashString( HashString && other )
        : _s( std::move( other._s ) )
        , _h( other._h )
    {
    }
    inline HashString & operator=( HashString && other )
    {
        _s = std::move( other._s );
        _h = other._h;
        return *this;
    }
    inline HashString & operator=( HashString const & other )
    {
        _s = other._s;
        _h = other._h;
        return *this;
    }
    inline bool operator==( HashString const& other ) const
    {
        return _h == other._h && _s == other._s;
    }
    //inline operator String const&( )
    //{
    //    return _s;
    //}
    //private:
    String _s;
    int _h;
};




    bool equalsTo( HashString* const& a, HashString* const& b )
    {
        return *a == *b;
    }
















//struct Foo : EnableSharedFromThis<Foo>
//{
//    Weak<Foo> parent;
//    List<Weak<Foo>> childs;
//
//    void addChild( Shared<Foo>& c )
//    {
//        c->parent = sharedFromThis();
//        childs.push( c );
//    }
//    Foo()
//    {
//        Cout( "Foo()" );
//    }
//    ~Foo()
//    {
//        Cout( "~Foo()" );
//    }
//};
//
//
//int main()
//{
//    {
//        std::aligned_storage<sizeof( SharedType<Foo> ), std::alignment_of<SharedType<Foo>>::value>::type buf;
//
//        auto f = makeSharedEx<Foo>( &buf, []
//        {
//            std::cout << "deleted" << std::endl;
//        } );
//
//
//
//
//        std::cout << " f._copys = " << f._st->_copys << " f._weaks = " << f._st->_weaks << std::endl;
//
//        f->addChild( f );
//        std::cout << " f._copys = " << f._st->_copys << " f._weaks = " << f._st->_weaks << std::endl;
//
//        f->addChild( f );
//        std::cout << " f._copys = " << f._st->_copys << " f._weaks = " << f._st->_weaks << std::endl;
//
//        f->addChild( f );
//        std::cout << " f._copys = " << f._st->_copys << " f._weaks = " << f._st->_weaks << std::endl;
//
//    }
//
//    return 0;
//}
























//#include "Lib/All.h"
//#include "PacketTestPackets.h"
//using namespace PacketTestPackets;
//
//int main()
//{
//
//    // todo: Éú³ÉÎïÔö¼Ó fillTo( fb, p1, p2, ... ) ÒÔ¼° fillTo( fb, T& dest ) °æ
//
//    //FlatBuffer fb;
//    //Foo f;
//    //f._isss[ 0 ][ 0 ][ 0 ] = 1;
//    //f._isss[ 1 ][ 0 ][ 0 ] = 2;
//    //f._isss[ 2 ][ 0 ][ 0 ] = 3;
//    //f._isss[ 0 ][ 1 ][ 0 ] = 4;
//    //f._isss[ 1 ][ 1 ][ 0 ] = 5;
//    //f._isss[ 2 ][ 1 ][ 0 ] = 6;
//    //fb.write( f );
//    //Cout( fb.dump() );
//
//    ////FlatBuffer fb;
//    //////Foo3 f;
//    //////f._f._f._bool = true;
//    //////f._f._f._byte = 1;
//    //////f._f._f._short = 2;
//    //////f._f._f._int = 3;
//    //////f._f._f._long = 4;
//    //////f._f._int = 5;
//    //////f._s = "asdfqwer";
//
//    ////int n = 99999999;
//
//    ////Foo f;
//    ////Stopwatch sw;
//    ////sw.reset();
//    ////for( int i = 0; i < n; ++i )
//    ////{
//    ////    fb.clear();
//    ////    f.writeBufferDirect( fb );
//    ////}
//    ////Cout( sw.elapsedMillseconds() );
//    ////Cout( fb.dump() );
//
//    ////sw.reset();
//    ////for( int i = 0; i < n; ++i )
//    ////{
//    ////    fb.offset() = 0;
//    ////    if( !f.readBuffer( fb ) ) return 0;
//    ////}
//    ////Cout( sw.elapsedMillseconds() );
//    ////Cout( f._byte );
//    //////Cout( f._long );
//
//    ////Cout( std::is_pod<Foo>::value );
//    ////Cout( std::is_pod<Foo2>::value );
//    ////Cout( std::is_pod<Foo3>::value );
//
//    system( "pause" );
//    return 0;
//}












#include "Lib/All.h"

int main()
{

    //// À´¸ö counter ÓÃÓÚÏÔÊ¾ ÒÔÌåÏÖ Ñ­»·ËÙ¶È
    //int counter = 0;
    //// timer Ïà¹Ø
    //std::chrono::milliseconds refreshDuration( 200 );
    //std::chrono::seconds durationSec1( 1 );
    //std::chrono::time_point<std::chrono::system_clock> lastTime;
    //auto firstTime = std::chrono::system_clock::now();

    //while( true )
    //{
    //    counter++;
    //    std::this_thread::sleep_for( std::chrono::milliseconds( 0 ) );

    //    auto now = std::chrono::system_clock::now();
    //    if( now - lastTime >= refreshDuration )
    //    {
    //        auto elapsedSeconds = std::chrono::duration_cast<std::chrono::seconds>( now - firstTime ).count();
    //        if( !elapsedSeconds ) elapsedSeconds = 1;
    //        CoutPos( 0, 0, counter, ", ", counter / elapsedSeconds );
    //        lastTime = now;
    //    }
    //}

    return 0;
}






#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    int count = 999999;
    OldPool p( 64, 4096, count, true );
    FlatQueue<String> fq( count );
    std::deque<std::string> dq;

    Stopwatch sw;
    for( int i = 0; i < count; ++i )
    {
        dq.emplace_back( "12345678901234567890123456789012345678901234567890" );
    }
    cout( sw.elapsed(), " ", dq.size() );


    sw.reset();
    for( int i = 0; i < count; ++i )
    {
        fq.emplace( p, "12345678901234567890123456789012345678901234567890" );
    }
    cout( sw.elapsed(), " ", fq.size() );

    system( "pause" );

    //FlatQueue<std::string> fq;

    //Stopwatch sw;
    //for( int i = 0; i < count; ++i )
    //{
    //    fq.emplace( "12345678901234567890123456789012345678901234567890" );
    //}
    //cout( sw.elapsed(), " ", fq.size() );

    //std::deque<std::string> dq;

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    dq.emplace_back( "12345678901234567890123456789012345678901234567890" );
    //}
    //cout( sw.elapsed(), " ", dq.size() );



    //FlatQueue<int> fq( count);

    //Stopwatch sw;
    //for( int i = 0; i < count; ++i )
    //{
    //    fq.push( i );
    //}
    //cout( sw.elapsed(), " ", fq.size() );

    //std::deque<int> dq;
    //dq.resize( count );

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    dq.push_back( i );
    //}
    //cout( sw.elapsed(), " ", dq.size() );


    return 0;
}























#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    Stopwatch sw;
    {
        std::string s;
        s.reserve( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s += std::to_string( i ) + std::to_string( -i );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );
    sw.reset();
    {
        String s( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s.append( String::toString( i ), String::toString( -i ) );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );
    sw.reset();
    {
        String s( 147777764 );
        for( int i = 0; i < 9999999; ++i )
        {
            s.append( i, -i );
        }
        cout( s.size() );
    }
    cout( sw.elapsed() );

    return 0;
}


















// it's not thread safe!!
template<int size, int count>
class StringPool
{
    typedef char Buf[ size ];
public:
    inline static Buf& alloc()
    {
        static int idx = 0;
        static Buf items[ count ];
        return items[ ( idx++ ) & count ];
    }
    inline static String make()
    {
        return String( alloc(), size, 0 );
    }
};

typedef StringPool<128, 8> SP;



















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    //int const count = 9999999;
    //Stopwatch sw;
    //OldPool p( 64, 4096, count, true );
    //cout( "new pool, elapsed time = ", sw.elapsed() );
    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    p.alloc();
    //}
    //cout( "alloc, elapsed time = ", sw.elapsed() );

    //sw.reset();
    //for( int i = 0; i < count; ++i )
    //{
    //    new char[ 64 ];
    //}
    //cout( "new, elapsed time = ", sw.elapsed() );




    int const count = 9999999;
    Stopwatch sw;
    {
        std::vector<std::string> ss;
        ss.reserve( count );

        sw.reset();
        for( int i = 0; i < count; ++i )
        {
            ss.emplace_back( "12345678901234567890123456789012345678901234567890" );
        }
        cout( "push std strings, elapsed time = ", sw.elapsed() );

        cout( ss[ count - 1 ] );
        sw.reset();
    }
    cout( "free std ss, elapsed time = ", sw.elapsed() );

    sw.reset();
    OldPool p( 64, 4096, count, true );
    cout( "new pool, elapsed time = ", sw.elapsed() );
    {
        List<String> ss( count );

        sw.reset();
        for( int i = 0; i < count; ++i )
        {
            // ´Ó OldPool ·ÖÅä String µÄÊ×·¢ÄÚ´æ ²¢¸´ÖÆÄÚÈÝ½øÈ¥
            ss.emplace( p, "12345678901234567890123456789012345678901234567890" );
        }
        cout( "push Strings, elapsed time = ", sw.elapsed() );
        cout( ss[ count - 1 ] );

        sw.reset();
    }
    cout( "free ss, elapsed time = ", sw.elapsed() );




    return 0;
}




























#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    int const count = 9999999;
    Stopwatch sw;
    {
        OldPool p( 4, 4096, count );
        cout( p.size(), "  ", p.pageCount(), " new pool, elapsed time = ", sw.elapsed() );

        sw.reset();
        p.compress();
        cout( p.size(), "  ", p.pageCount(), " compress, elapsed time = ", sw.elapsed() );

        sw.reset();
        List<void*> tmp( count );
        for( int i = 0; i < count; ++i )
        {
            tmp.push( p.alloc() );
        }
        cout( p.size(), "  ", p.pageCount(), " alloc capacity, elapsed time = ", sw.elapsed() );

        sw.reset();
        while( tmp.size() )
        {
            p.free( tmp.top() );
            tmp.pop();
        }
        cout( p.size(), "  ", p.pageCount(), " free capacity, elapsed time = ", sw.elapsed() );

        sw.reset();
        p.compress();
        cout( p.size(), "  ", p.pageCount(), " compress, elapsed time = ", sw.elapsed() );
    }
    cout( "delete pool, elapsed time = ", sw.elapsed() );

    system( "pause" );
    return 0;
}




















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}
int main()
{
    int count = 9999;
    Stopwatch sw;
    List<String> ss;
    for( int i = 0; i < count; ++i )
    {
        //ss.emplace( "asdfqwer" );
        //ss.push( "asdfqwer" );
        ss.insertAt( 0, "asdfqwer" );
    }
    cout( sw.elapsed(), ", ", ss.size() );

    std::vector<String> ss2;
    sw.reset();
    for( int i = 0; i < count; ++i )
    {
        //ss2.emplace_back( "asdfqwer" );
        //ss2.push_back( "asdfqwer" );
        ss2.insert( ss2.begin(), "asdfqwer" );
    }
    cout( sw.elapsed(), ", ", ss2.size() );


    sw.reset();
    int c = 0;
    while( ss.size() )
    {
        ss.erase( 0 );
        c++;
    }
    cout( sw.elapsed(), ", ", ss.size(), ",", c );

    sw.reset();
    c = 0;
    while( ss2.size() )
    {
        ss2.erase( ss2.begin() );
        c++;
    }
    cout( sw.elapsed(), ", ", ss2.size(), ",", c );


    return 0;
}



















#include "Lib/All.h"
template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}


int main()
{
    int count = 9999999;
    String s;
    Stopwatch sw;
    String tmp;
    for( int i = 0; i < count; ++i )
    {
        tmp.clear();
        tmp.appendFormat( "{2} {1} {0} {2} {1} {0} {2}", "World", "Hello", i );
        s = tmp;
    }
    cout( sw.elapsed(), "  ", s );




    /*String s;
    int count = 999999;
    Stopwatch sw;

    sw.reset();
    for( int i = 0; i < count; ++i )
    {
    s.clear();
    s.appendFormat( "{1}{99}{1}"
    , 1, 2, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1
    , 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 100
    );
    }
    cout( s, ' ', sw.elapsed() );

    */

    return 0;





    //FlatBuffer fb;

    //int count = 999999;
    //// ·ÂÒ»¸ö×ÖµäÊý¾Ý
    //fb.write( count );
    //for( int i = 0; i < count; ++i )
    //{
    //    fb.writes( i, String::toString( i ) );
    //}

    //Stopwatch sw;
    //// »¹Ô­
    //fb.offset() = 0;
    //Dict<int, int> d;
    //if( !fb.read( d ) ) cout( "read fail." );
    //cout( d.size(), ' ', d[ 0 ], ' ', d[ count - 1 ], ", elapsed ms = ", sw.elapsed() );

    //sw.reset();
    //fb.offset() = 0;
    //std::unordered_map<int, int> sd;
    //int len;
    //fb.read( len );
    //for( int i = 0; i < len; ++i )
    //{
    //    int k, v;
    //    if( !fb.read( k ) ) cout( "read fail." );
    //    if( !fb.read( v ) ) cout( "read fail." );
    //    sd.insert( std::make_pair( k, v ) );
    //}
    //cout( sd.size(), ' ', sd[ 0 ], ' ', sd[ count - 1 ], ", elapsed ms = ", sw.elapsed() );

    return 0;
}






















#include "Lib/All.h"




enum class Xxxxs : byte
{
    Asdf, Qwer, Zxcv
};

struct Foo
{
    int i;
    double d;
    float f;
    String s;
    byte b[ 9 ];
    Xxxxs e[ 3 ];
#pragma region
    // for FlatBuffer write
    inline int getWriteBufferSize() const
    {
        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + sizeof( b ) + sizeof( e );
    }
    inline void writeBuffer( FlatBuffer& fb ) const
    {
        fb.writes( i, d, f, s, b, e );
    }
    inline void writeBufferDirect( FlatBuffer& fb ) const
    {
        fb.writesDirect( i, d, f, s, b, e );
    }
    inline bool readBuffer( FlatBuffer& fb )
    {
        return fb.reads( i, d, f, s, b, e );
    }
#pragma endregion
};

//
//struct Foos
//{
//    int i;
//    double d;
//    float f;
//    String s;
//    List<Foo> fs;
//    // for FlatBuffer write
//    inline int getWriteBufferSize() const
//    {
//        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + fs.getWriteBufferSize();
//    }
//    //inline void writeBuffer( FlatBuffer& fb ) const
//    //{
//    //    fb.writes( i, d, f, s, fs );
//    //}
//    inline void writeBufferDirect( FlatBuffer& fb ) const
//    {
//        fb.writesDirect( i, d, f, s, fs );
//    }
//    inline bool readBuffer( FlatBuffer& fb )
//    {
//        return fb.reads( i, d, f, s, fs );
//    }
//};

template<typename ...TS>
void cout( TS const& ...parms )
{
    String s;
    s.append( parms... );
    std::cout << s.c_str() << std::endl;
}

int main()
{
    Dict<int, int> d;
    d.insert( 1, 1 );
    d.insert( 2, 2 );
    d.insert( 3, 3 );
    FlatBuffer fb;
    fb.write( d );
    cout( fb.dump() );

    Dict<int, int> d2;
    fb.read( d2 );
    for( int i = 0; i < d2.size(); ++i )
    {
        auto n = d2.data()[ i ];
        cout( n->key, " ", n->value );
    }


    //Foo f[] = { { 234, 234.5, 234.567f, "kjjljkjlkj"
    //    , { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv } } };

    //FlatBuffer fb;
    //fb.write( f );
    //cout << fb.dump().c_str() << endl;

    //Foo ff[1];
    //fb.read( ff );
    //auto& f2 = ff[ 0 ];
    //cout << f2.i << " " << f2.d << " " << f2.f << " " << f2.s.c_str() << " "
    //    << (int)f2.b[ 0 ] << " " << (int)f2.b[ 8 ] << " " 
    //    << (int)f2.e[ 0 ] << " " << (int)f2.e[ 2 ] << endl;



    //FlatBuffer fb;
    //Xxxxs iii[] = { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv };
    //fb.write( iii );
    //cout << fb.dump().c_str() << endl;
    //
    //memset( iii, 0, sizeof(iii) );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //fb.read( iii );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //FlatBuffer fb;
    //fb.writes( 123, 234.0f, 345.01, "0123456789", true );
    //int I;
    //if( !fb.read( I ) )
    //{
    //    cout << "!fb.read( I )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb.read( F ) )
    //{
    //    cout << "!fb.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb.read( D ) )
    //{
    //    cout << "!fb.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb.read( S ) )
    //{
    //    cout << "!fb.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb.read( B ) )
    //{
    //    cout << "!fb.read( B )" << endl;
    //    return 0;
    //}
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << (B?"true":"false") << endl;
    //cout << fb.offset() << endl;

    //fb.offset() = 0;
    //I = 0; F = 0; D = 0; S.clear(); B = false;
    //fb.reads( I, F, D, S, B );
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << ( B ? "true" : "false" ) << endl;

    //cout << fb.offset() << endl;






    //FlatBuffer fb;
    //{
    //    List<Foos> fooss;
    //    Foos foos = { 234, 234.567, 234.567f, "kjjljkjlkj" };
    //    Foo f = { 123, 123.456, 123.456f, "asdfqwer" };
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fb.write( fooss );
    //}
    //cout << fb.dump().c_str() << endl;
    //{
    //    fb.size()--;    // ¹ÊÒâÁîÊý¾Ý²»È«
    //    List<Foos> fooss;
    //    cout << (fb.read( fooss ) ? "read success\n" : "read fail\n");
    //    cout << fooss.size() << endl;
    //}







    //FlatBuffer fb111;
    //{
    //    List<List<List<String>>> llls;
    //    List<List<String>> lls;
    //    List<String> ls;
    //    ls.push( "ooooo" );
    //    ls.push( "xxxxx" );
    //    lls.push( ls );
    //    lls.push( ls );
    //    llls.push( lls );
    //    llls.push( lls );

    //    FlatBuffer fb;
    //    Stopwatch sw;
    //    for( int i = 0; i < 9999999; i++ )
    //    {
    //        fb.clear();
    //        fb.writes( llls, 123, 1.23f, 1.23, "asdfqwerzxcv1234", (byte)123, true );
    //    }
    //    cout << sw.elapsed() << endl;
    //    cout << fb.dump().c_str() << endl;

    //    fb111 = fb;
    //}

    // todo: FBRead

    //int I;
    //if( !fb111.read( I ) )
    //{
    //    cout << "!fb111.read( I )" << endl;
    //    return 0;
    //}
    //List<List<List<String>>> llls;
    //if( !fb111.read( llls ) )
    //{
    //    cout << "!fb111.read( llls )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb111.read( F ) )
    //{
    //    cout << "!fb111.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb111.read( D ) )
    //{
    //    cout << "!fb111.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb111.read( S ) )
    //{
    //    cout << "!fb111.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb111.read( B ) )
    //{
    //    cout << "!fb111.read( B )" << endl;
    //    return 0;
    //}

    //for( int i = 0; i < llls.size(); ++i )
    //{
    //    auto& lls = llls[ i ];
    //    for( int j = 0; j < lls.size(); ++j )
    //    {
    //        auto& ls = lls[ j ];
    //        for( int k = 0; k < ls.size(); ++k )
    //        {
    //            cout << ls[ k ].c_str() << endl;
    //        }
    //    }
    //}


    return 0;
}



















#include "Lib/All.h"
using namespace std;




enum class Xxxxs : byte
{
    Asdf, Qwer, Zxcv
};

struct Foo
{
    int i;
    double d;
    float f;
    String s;
    byte b[ 9 ];
    Xxxxs e[ 3 ];
#pragma region
    // for FlatBuffer write
    inline int getWriteBufferSize() const
    {
        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + sizeof( b ) + sizeof( e );
    }
    inline void writeBuffer( FlatBuffer& fb ) const
    {
        fb.writes( i, d, f, s, b, e );
    }
    inline void writeBufferDirect( FlatBuffer& fb ) const
    {
        fb.writesDirect( i, d, f, s, b, e );
    }
    inline bool readBuffer( FlatBuffer& fb )
    {
        return fb.reads( i, d, f, s, b, e );
    }
#pragma endregion
};

//
//struct Foos
//{
//    int i;
//    double d;
//    float f;
//    String s;
//    List<Foo> fs;
//    // for FlatBuffer write
//    inline int getWriteBufferSize() const
//    {
//        return sizeof( int ) + sizeof( double ) + sizeof( float ) + s.size() + fs.getWriteBufferSize();
//    }
//    //inline void writeBuffer( FlatBuffer& fb ) const
//    //{
//    //    fb.writes( i, d, f, s, fs );
//    //}
//    inline void writeBufferDirect( FlatBuffer& fb ) const
//    {
//        fb.writesDirect( i, d, f, s, fs );
//    }
//    inline bool readBuffer( FlatBuffer& fb )
//    {
//        return fb.reads( i, d, f, s, fs );
//    }
//};

int main()
{

    Foo f[] = { { 234, 234.5, 234.567f, "kjjljkjlkj"
        , { 0, 1, 2, 3, 4, 5, 6, 7, 8 }, { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv } } };

    FlatBuffer fb;
    fb.write( f );
    cout << fb.dump().c_str() << endl;

    Foo ff[1];
    fb.read( ff );
    auto& f2 = ff[ 0 ];
    cout << f2.i << " " << f2.d << " " << f2.f << " " << f2.s.c_str() << " "
        << (int)f2.b[ 0 ] << " " << (int)f2.b[ 8 ] << " " 
        << (int)f2.e[ 0 ] << " " << (int)f2.e[ 2 ] << endl;



    //FlatBuffer fb;
    //Xxxxs iii[] = { Xxxxs::Asdf, Xxxxs::Qwer, Xxxxs::Zxcv };
    //fb.write( iii );
    //cout << fb.dump().c_str() << endl;
    //
    //memset( iii, 0, sizeof(iii) );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //fb.read( iii );
    //cout << (int)iii[ 0 ] << (int)iii[ 1 ] << (int)iii[ 2 ] << endl;

    //FlatBuffer fb;
    //fb.writes( 123, 234.0f, 345.01, "0123456789", true );
    //int I;
    //if( !fb.read( I ) )
    //{
    //    cout << "!fb.read( I )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb.read( F ) )
    //{
    //    cout << "!fb.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb.read( D ) )
    //{
    //    cout << "!fb.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb.read( S ) )
    //{
    //    cout << "!fb.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb.read( B ) )
    //{
    //    cout << "!fb.read( B )" << endl;
    //    return 0;
    //}
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << (B?"true":"false") << endl;
    //cout << fb.offset() << endl;

    //fb.offset() = 0;
    //I = 0; F = 0; D = 0; S.clear(); B = false;
    //fb.reads( I, F, D, S, B );
    //cout << I << ", " << F << ", " << D << ", " << S.c_str() << ", " << ( B ? "true" : "false" ) << endl;

    //cout << fb.offset() << endl;






    //FlatBuffer fb;
    //{
    //    List<Foos> fooss;
    //    Foos foos = { 234, 234.567, 234.567f, "kjjljkjlkj" };
    //    Foo f = { 123, 123.456, 123.456f, "asdfqwer" };
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    foos.fs.push( f );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fooss.push( foos );
    //    fb.write( fooss );
    //}
    //cout << fb.dump().c_str() << endl;
    //{
    //    fb.size()--;    // ¹ÊÒâÁîÊý¾Ý²»È«
    //    List<Foos> fooss;
    //    cout << (fb.read( fooss ) ? "read success\n" : "read fail\n");
    //    cout << fooss.size() << endl;
    //}







    //FlatBuffer fb111;
    //{
    //    List<List<List<String>>> llls;
    //    List<List<String>> lls;
    //    List<String> ls;
    //    ls.push( "ooooo" );
    //    ls.push( "xxxxx" );
    //    lls.push( ls );
    //    lls.push( ls );
    //    llls.push( lls );
    //    llls.push( lls );

    //    FlatBuffer fb;
    //    Stopwatch sw;
    //    for( int i = 0; i < 9999999; i++ )
    //    {
    //        fb.clear();
    //        fb.writes( llls, 123, 1.23f, 1.23, "asdfqwerzxcv1234", (byte)123, true );
    //    }
    //    cout << sw.elapsed() << endl;
    //    cout << fb.dump().c_str() << endl;

    //    fb111 = fb;
    //}

    // todo: FBRead

    //int I;
    //if( !fb111.read( I ) )
    //{
    //    cout << "!fb111.read( I )" << endl;
    //    return 0;
    //}
    //List<List<List<String>>> llls;
    //if( !fb111.read( llls ) )
    //{
    //    cout << "!fb111.read( llls )" << endl;
    //    return 0;
    //}
    //float F;
    //if( !fb111.read( F ) )
    //{
    //    cout << "!fb111.read( F )" << endl;
    //    return 0;
    //}
    //double D;
    //if( !fb111.read( D ) )
    //{
    //    cout << "!fb111.read( D )" << endl;
    //    return 0;
    //}
    //String S;
    //if( !fb111.read( S ) )
    //{
    //    cout << "!fb111.read( S )" << endl;
    //    return 0;
    //}
    //byte B;
    //if( !fb111.read( B ) )
    //{
    //    cout << "!fb111.read( B )" << endl;
    //    return 0;
    //}

    //for( int i = 0; i < llls.size(); ++i )
    //{
    //    auto& lls = llls[ i ];
    //    for( int j = 0; j < lls.size(); ++j )
    //    {
    //        auto& ls = lls[ j ];
    //        for( int k = 0; k < ls.size(); ++k )
    //        {
    //            cout << ls[ k ].c_str() << endl;
    //        }
    //    }
    //}


    return 0;
}
























#include "Lib/All.h"
#include "vld.h"
using namespace std;
int main()
{
    {
        FlatBuffer fb;
        fb.writes( 123, 1.23f, 1.23, "asdf", (byte)123 );
        auto fb2 = fb;
        cout << fb2.dump().c_str() << endl;
    }
    return 0;
}


















#include "Lib/All.h"
using namespace std;
int main()
{
    {
        Dict<String, String> d;
        Stopwatch sw;
        for( int i = 0; i < 99999; ++i )
        {
            d.insert( String::make( "asdfqwerasdfqwerasdfqwer", i ), String::make( "asdfqwerasdfqwerasdfqwer", i ) );
        }
        cout << sw.elapsed() << endl;
        sw.reset();
        auto d2 = move( d );
        //for( int i = 0; i < 99; ++i )
        //{
        //    d2 = move( d );
        //}
        cout << sw.elapsed() << endl;
        cout << d2.find( "asdfqwerasdfqwerasdfqwer99998" )->value.c_str() << endl;
    }

    {
        unordered_map<string, string> d;
        Stopwatch sw;
        for( int i = 0; i < 99999; ++i )
        {
            d.insert( make_pair( "asdfqwerasdfqwerasdfqwer" + to_string( i ), "asdfqwerasdfqwerasdfqwer" + to_string( i ) ) );
        }
        cout << sw.elapsed() << endl;
        sw.reset();
        auto d2 = move(d);
        //for( int i = 0; i < 99; ++i )
        //{
        //    d2 = d;
        //}
        cout << sw.elapsed() << endl;
        cout << d2[ "asdfqwerasdfqwerasdfqwer99998" ] << endl;
    }

    return 0;
}























#include "Lib/All.h"
using namespace std;
int main()
{
    List<String> ls;
    ls.reserve( 9999999 );
    OldPool p( 128, 4096, 9999999, true );
    cout << "pool size = " << p.size() << endl;

    Stopwatch sw;
    for( int i = 0; i < 9999999; ++i )
    {
        ls.push( String( p ) );
    }
    cout << "ls.push( String( p ) );  time = " << sw.elapsed() << endl;
    cout << "pool size = " << p.size() << endl;

    sw.reset();
    ls.clear();
    cout << "ls.clear();  time = " << sw.elapsed() << endl;
    cout << "pool size = " << p.size() << endl;

    vector<string> vs;
    vs.reserve( 9999999 );
    sw.reset();
    for( int i = 0; i < 9999999; ++i )
    {
        string s;
        s.reserve( 128 );
        vs.push_back( move( s ) );
    }
    cout << "vs.push_back( move( s ) );  time = " << sw.elapsed() << endl;

    sw.reset();
    vs.clear();
    cout << "vs.clear();  time = " << sw.elapsed() << endl;

    return 0;
}


























#include "Lib/All.h"
using namespace std;
int main()
{
    OldPool p( 128, 4096, 9999999 );
    cout << "pool size " << p.size() << endl;
    {
        vector<String> ss;
        ss.reserve( 9999999 );
        Stopwatch sw;
        for( int i = 0; i < 9999999; ++i )
        {
            ss.push_back( String( p ) );// (char*)p.alloc(), 128, 0 ) );
        }
        cout << sw.elapsed() << endl;
        cout << "pool size " << p.size() << endl;
        sw.reset();
        for( int i = 0; i < 9999999; ++i )
        {
            ss[ i ].appendFormat( "hi, {0}! {1} hi, {0}! {1} hi, {0}! {1} hi, {0}! {1}", "asdf", i );
        }
        cout << sw.elapsed() << endl;
        cout << ss[ ss.size() - 1 ].c_str() << endl;
    }
    cout << "pool size " << p.size() << endl;

    return 0;
}
















#include "Lib/All.h"
using namespace std;

int main()
{
    //LRUCache<int, int> c( 5 );
    //c.insert( 1, 1 );
    //c.insert( 2, 2 );
    //c.insert( 3, 3 );
    //c.insert( 4, 4 );
    //c.insert( 5, 5 );
    //c.dump();
    //c.insert( 6, 6 );   // 1 will be lost
    //c.dump();
    //if( c.find( 1 ) ) cout << "found 1" << endl;
    //if( c.find( 2 ) ) cout << "found 2" << endl;
    //c.insert( 7, 7 );   // 3 will be lost
    //c.dump();

    //char buf[] = "asdfasdfhasdfklsdjf12312k3jh1l2k3j";
    //String s;
    //Utils::dumpBinary( s, buf, _countof( buf ) );
    //cout << s.c_str() << endl;

    return 0;
}

















int main()
{
    OldPool p( 16, 4096, 1 );
    CircleBuffer lb( p );
    cout << "p.size = " << p.size() << endl;

    lb.write( "1234567890", 10 );
    lb.write( "12345678901234567890", 20 );
    lb.write( "1234567890123456789012345678901234567890", 40 );
    lb.write( "1", 1 );
    lb.write( "", 0 );

    cout << "p.size = " << p.size() << endl;

    char buf[ 128 ];
    lb.copy( buf, 60 );
    buf[ 60 ] = 0;
    cout << "copy buf 60 " << buf << endl;

    for( int i = 0; i < 16; ++i )
    {
        lb.write( "1", 1 );
        auto len = lb.read( buf, 128 );
        buf[ len ] = 0;
        cout << len << " " << buf << endl;
    }
    cout << "p.size = " << p.size() << endl;
    lb.clear();
    cout << "p.size = " << p.size() << endl;
    return 0;
}
































#include "Lib/All.h"
using namespace std;
int main()
{
    //int count = 9999999;
    //string s;
    //Stopwatch sw;
    //String tmp( 64 );
    //for( int i = 0; i < count; ++i )
    //{
    //    tmp.appendFormat( "{2} {1} {0} {2} {1} {0} {2}", "World", "Hello", i );
    //    s.assign( tmp.c_str(), tmp.size() );
    //    tmp.clear();
    //}
    //cout << sw.elapsed() << "  " << s << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new List<Dict<HashString*, int>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new Dict<HashString*, int>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        //items->insert( HashString( String::make( i, ',', j ) ), j );
    //        items->insert( new HashString( String::make( j ) ), j );
    //    }
    //    data->push( items );
    //    //items->insert( HashString( "erererere" ), 123 );  // ÖÆÔìÒ»¸ö½»¼¯
    //}

    //Dict<HashString*, int> result1( num_groups * num_items );
    //Dict<HashString*, int> result2( num_groups * num_items );
    //Dict<HashString*, int> result3( num_groups * num_items );

    //Stopwatch sw;
    //auto& d0 = *data->at( 0 );
    //auto& d1 = *data->at( 1 );
    //auto& d2 = *data->at( 2 );
    //auto& d3 = *data->at( 3 );
    //for( int i = 0; i < d0.size(); ++i )
    //{
    //    auto n = d0.data()[ i ];
    //    if( d1.find( n->key ) )
    //    {
    //        result1.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result1.size(); ++i )
    //{
    //    auto n = result1.data()[ i ];
    //    if( d2.find( n->key ) )
    //    {
    //        result2.insert( n->key, n->value );
    //    }
    //}
    //for( int i = 0; i < result2.size(); ++i )
    //{
    //    auto n = result2.data()[ i ];
    //    if( d3.find( n->key ) )
    //    {
    //        result3.insert( n->key, n->value );
    //    }
    //}
    //cout << sw.elapsed() << endl;
    //cout << result3.size() << endl;





    //data[0]
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        if( auto o = dict.insert( items->at( j ), 1, false ) )
    //        {
    //            ++o->value;
    //        }
    //    }
    //}
    //for( int i = 0; i < dict.size(); ++i )
    //{
    //    auto o = dict.data()[ i ];
    //    if( o->value == data->size() )
    //        result.push( o->key );
    //}
    //cout << sw.elapsed() << endl;
    //cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;


    return 0;
}

















    int num_groups = 4;
    int num_items = 200000;
    auto data = new List<List<HashString>*>();
    for( int i = 0; i < num_groups; ++i )
    {
        auto items = new List<HashString>();
        for( int j = 0; j < num_items; ++j )
        {
            items->push( HashString( String::make( i, ',', j ) ) );
            //items->push( String::make( i * num_items + j ) );
        }
        data->push( items );
        items->at( num_groups - 1 ) = HashString( "erererere" );  // ÖÆÔìÒ»¸ö½»¼¯
    }

    Dict<HashString, int> dict( num_groups * num_items );
    List<HashString> result( num_items );

    Stopwatch sw;
    for( int i = 0; i < data->size(); ++i )
    {
        auto items = data->at( i );
        for( int j = 0; j < items->size(); ++j )
        {
            if( auto o = dict.insert( items->at( j ), 1, false ) )
            {
                ++o->value;
            }
        }
    }
    for( int i = 0; i < dict.size(); ++i )
    {
        auto o = dict.data()[ i ];
        if( o->value == data->size() )
            result.push( o->key );
    }
    cout << sw.elapsed() << endl;
    cout << result.size() << endl;
    //for( int i = 0; i < result.size(); ++i )
    //    cout << result[ i ].c_str() << endl;



    //int num_groups = 4;
    //int num_items = 200000;
    //auto data = new vector<vector<string>*>();
    //for( int i = 0; i < num_groups; ++i )
    //{
    //    auto items = new vector<string>();
    //    for( int j = 0; j < num_items; ++j )
    //    {
    //        items->push_back( to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) + to_string( j ) );
    //        //items->push_back( to_string( i * num_items + j ) );
    //    }
    //    data->push_back( items );
    //}
    ////data->at( 0 )->at( 99 ) = "asdf";
    ////data->at( 1 )->at( 199 ) = "asdf";
    ////data->at( 2 )->at( 299 ) = "asdf";
    ////data->at( 3 )->at( 399 ) = "asdf";

    //unordered_map<string, int> dict;
    //dict.reserve( num_groups * num_items );
    //vector<string> result;
    //result.reserve( num_items );

    //Stopwatch sw;
    //for( int i = 0; i < data->size(); ++i )
    //{
    //    auto items = data->at( i );
    //    for( int j = 0; j < items->size(); ++j )
    //    {
    //        auto it = dict.insert( make_pair( items->at( j ), 1 ) );
    //        if( !it.second )
    //        {
    //            ++it.first->second;
    //        }
    //    }
    //}
    //for( auto& kv : dict )
    //{
    //    if( kv.second == data->size() )
    //        result.push_back( kv.first );
    //}
    //cout << sw.elapsed() << endl;

    //cout << result.size() << endl;
    ////for( int i = 0; i < result.size(); ++i )
    ////    cout << result[ i ].c_str() << endl;









Õâ¶ÎÊµÏÖ±ÈÏÈÉú³ÉcharÊý×éÔÙÆ´µÄ·½Ê½Âý 20% ( ¹À¼ÆÈç¹û´«Èë²ÎÊý×ªÎªµÄ×Ö´®ÔÙ³¤Ò»Ð©¾ÍÓÐ¸ãÍ·ÁË¡£Ò²¾ÍÊÇÊ¡µôÒ»´Îcopy )

    typedef std::function<void( String&s )> AppendFunc;
    template<typename T> static AppendFunc getAppendFunc( T const& v )
    {
        auto n = typeid( v ).name();
        return nullptr;
    };
    template<> static AppendFunc getAppendFunc( uint8   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint16  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( uint64  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int8    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int16   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int     const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( int64   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( double  const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( float   const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( bool    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char    const& v ) { return [ &](String&s) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( char const* const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( std::string const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<> static AppendFunc getAppendFunc( String  const& v ) { return [ &]( String&s ) { s.append( v ); }; }
    template<size_t len>
    static AppendFunc getAppendFunc( char const( &v )[ len ] ) { return [ &]( String&s ) { s.append( v ); }; }


    template<typename T>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v )
    {
        fs[ i ] = getAppendFunc( v );
    }

    template<typename T, typename ...TS>
    void appendFormatCore( AppendFunc* fs, int& i, T const & v, TS const & ...vs )
    {
        fs[ i++ ] = getAppendFunc( v );
        appendFormatCore( fs, i, vs... );
    }

    template<typename ...TS>
    void appendFormat( char const* format, TS const & ...vs )
    {
        AppendFunc fs[ sizeof...( vs ) ];
        std::pair<int, int> flags[ sizeof...( vs ) ];
        //memset( flags, 0, sizeof( flags ) );
        int i = 0;
        appendFormatCore( fs, i, vs... );

        char numBuf[ 32 ];
        String numStr( numBuf, 32 );
        int offset = 0;
        while( auto c = format[ offset ] )
        {
            if( c == '{' )
            {
                c = format[ ++offset ];
                if( c == '{' )
                {
                    push( '{' );
                }
                else
                {
                    while( c = format[ offset ] )
                    {
                        if( c == '}' )
                        {
                            Utils::fromString( i, numBuf );
                            numStr.clear();
                            if( i < 0 || i >= sizeof...( vs ) )
                            {
                                throw std::invalid_argument( "argument out of range." );
                            }
                            //append( ss[ i ] );
                            if( flags[ i ].second )
                            {
                                reserve( _dataLen + flags[ i ].second );
                                memcpy( _buf + _dataLen, _buf + flags[ i ].first, flags[ i ].second );
                                _dataLen += flags[ i ].second;
                                _buf[ _dataLen ] = '\0';
                            }
                            else
                            {
                                flags[ i ].first = _dataLen;
                                fs[ i ](*this);
                                flags[ i ].second = _dataLen - flags[ i ].first;
                            }

                            break;
                        }
                        else
                        {
                            numStr.push( c );
                        }
                        ++offset;
                    }
                }
            }
            else
            {
                push( c );
            }
            ++offset;
        }
    }





















#include "Lib/All.h"
int main()
{
    using namespace std;
    int length = 999999;


    {
        Dict<int, String> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, String::make( i ) );
        }
        cout << "Dict<int,String> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,String> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,String> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,String> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<int, string> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( i, to_string( i ) );
        }
        cout << "Dict<int,std::string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
            }
        }
        cout << "Dict<int,std::string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->key;
        }
        cout << "Dict<int,std::string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( i ) )
            {
                count += r->key;
                d.erase( r );
            }
        }
        cout << "Dict<int,std::string> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<int, string > d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( i, to_string( i ) ) );
        cout << "unordered_map<std::int,string> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
            }
        }
        cout << "unordered_map<std::int,string> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.first;
        }
        cout << "unordered_map<std::int,string> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( i );
            if( it != d.end() )
            {
                count += it->first;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::int,string> erase: " << sw.elapsed() << " " << count << endl;
    }





























    {
        Dict<String, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( String::make( i ), i );
        }
        cout << "Dict<String,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<String,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<String,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( String::make( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<String,int> erase: " << sw.elapsed() << " " << count << endl;
    }


    {
        Dict<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
        {
            d.insert( to_string( i ), i );
        }
        cout << "Dict<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
            }
        }
        cout << "Dict<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < d.size(); ++i )
        {
            count += d.data()[ i ]->value;
        }
        cout << "Dict<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            if( auto r = d.find( to_string( i ) ) )
            {
                count += r->value;
                d.erase( r );
            }
        }
        cout << "Dict<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }

    {
        unordered_map<string, int> d;
        Stopwatch sw;
        for( int i = 0; i < length; ++i )
            d.insert( make_pair( to_string( i ), i ) );
        cout << "unordered_map<std::string,int> insert: " << sw.elapsed() << " " << d.size() << endl;

        sw.reset();
        uint count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
            }
        }
        cout << "unordered_map<std::string,int> find: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( auto& it : d )
        {
            count += it.second;
        }
        cout << "unordered_map<std::string,int> foreach: " << sw.elapsed() << " " << count << endl;

        sw.reset();
        count = 0;
        for( int i = 0; i < length; ++i )
        {
            auto it = d.find( to_string( i ) );
            if( it != d.end() )
            {
                count += it->second;
                d.erase( it );
            }
        }
        cout << "unordered_map<std::string,int> erase: " << sw.elapsed() << " " << count << endl;
    }
    return 0;
}






























#include "Lib/All.h"
int main()
{
    //{
    //    int length = 9999999;
    //    List<bool> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << ( s1.top() ? "true" : "false" ) << std::endl;
    //    std::cout << s1.byteSize() << std::endl;

    //    //while( s1.size() )
    //    //{
    //    //    std::cout << ( s1.top() ? "true " : "false " );
    //    //    s1.pop();
    //    //}
    //    //std::cout << s1.byteSize() << std::endl;

    //    sw.reset();
    //    std::stack<bool> s2;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s2.push( ( i % 2 ) == 0 );
    //    }
    //    std::cout << sw.elapsed() << " " << s2.size() << " " << ( s2.top() ? "true" : "false" ) << std::endl;
    //}

    //{
    //    int length = 10000000;
    //    List<char> s1;
    //    Stopwatch sw;
    //    for( int i = 0; i < length; ++i )
    //    {
    //        s1.push( i );
    //    }
    //    std::cout << sw.elapsed() << " " << s1.size() << " " << s1.top() << std::endl;
    //}
    //sw.reset();
    //List<char> s11;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s11 = s1;
    //}
    //std::cout << sw.elapsed() << " " << s11.size() << " " << s11.top() << std::endl;

    //std::stack<char> s2;
    //sw.reset();
    //for( int i = 0; i < length; ++i )
    //{
    //    s2.push( i );
    //}
    //std::cout << sw.elapsed() << " " << s2.size() << " " << s2.top() << std::endl;
    //sw.reset();
    //std::stack<char> s22;
    //for( int i = 0; i < 999; ++i )
    //{
    //    s22 = s2;
    //}
    //std::cout << sw.elapsed() << " " << s22.size() << " " << s22.top() << std::endl;



    //std::cout << sizeof( OldPool<4,4096> ) << std::endl;

    OldPool pool( 4 );
    pool.collect();
    //for( int i = 0; i < 999; ++i )
    //{
    //    auto p = (int*)pool.alloc();
    //    std::cout << p << std::endl;
    //}
    //pool.clear();

    return 0;
}





//#include "Lib/All.h"
//int main()
//{
//    //String s = "a";
//    //std::cout << s.getHash() << std::endl;
//    //s = "as";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asd";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdf";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfq";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqw";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwe";
//    //std::cout << s.getHash() << std::endl;
//    //s = "asdfqwer";
//    //std::cout << s.getHash() << std::endl;
//    String s = "asdfqwerasdfqwerasdfqwerasdfqwer";
//    int hash = 0;
//    Stopwatch sw;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_CS();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Java();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    sw.reset();
//    for( int i = 0; i < 99999999; ++i )
//    {
//        hash = s.getHash_Lua();
//    }
//    std::cout << hash << ", " << sw.elapsed() << std::endl;
//    return 0;
//}




//#include "Lib/All.h"
//
//int main()
//{
//String s1( "ASDFQWERASDFQWERASDFQWER", true );          // ref str
//char buf[ 16 ];
//String s2( buf, _countof( buf ), 0 );   // ref buf
//s2 = s1;                                // copy str to buf
//String s3 = buf;                        // copy from buf


//Stopwatch sw;
//{
//    std::string s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        for( int i = 0; i < s.size(); i++ )
//            s[ i ] = tolower( s[ i ] );
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

//sw.reset();
//{
//    String s;
//    for( int i = 0; i < 99999999; ++i )
//    {
//        s = s1;
//        //s.toLower();
//        s.toLowerUnsafe();
//    }
//    std::cout << s << std::endl;
//}
//std::cout << sw.elapsed() << std::endl;

////int equal = 0, less = 0, larger = 0;
////Stopwatch sw;
////{
////    std::string s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

////equal = 0, less = 0, larger = 0;
////sw.reset();
////{
////    String s1 = "aaaasdfasdf", s2 = s1, s3 = "aaaasdfasda";
////    for( int i = 0; i < 99999999; ++i )
////    {
////        if( s1 == s2 ) ++equal;
////        if( s3 < s1 ) ++less;
////        if( s1 > s3 ) ++larger;
////    }
////}
////std::cout << equal << " " << less << " " << larger << " " << sw.elapsed() << std::endl;

//    return 0;
//}
//









//
//#include "Lib/All.h"
//#include "String.h"
//using namespace std;
//int main()
//{
//    auto ¶¨³¤´® = "asdfqer";
//    Stopwatch sw;
//    sw.reset();
//    {
//        String s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // ÊÖÊÖÇå£¬²»²âÄÚ´æ·ÖÅä
//            s.append( ¶¨³¤´®, i, ¶¨³¤´®, i, ¶¨³¤´®, i, ¶¨³¤´®, i );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    sw.reset();
//    {
//        std::string s;
//        //s.reserve( 128 );
//        for( int i = 0; i < 9999999; ++i )
//        {
//            //s.clear();  // ÊÖÊÖÇå£¬²»²âÄÚ´æ·ÖÅä
//            s.append( ¶¨³¤´® );
//            s.append( std::to_string( i ) );
//            s.append( ¶¨³¤´® );
//            s.append( std::to_string( i ) );
//            s.append( ¶¨³¤´® );
//            s.append( std::to_string( i ) );
//            s.append( ¶¨³¤´® );
//            s.append( std::to_string( i ) );
//        }
//        std::cout << s.c_str()[ 0 ] << s.size() << std::endl;
//    }
//    std::cout << sw.elapsed() << std::endl;
//    return 0;
//}
























//#include <iostream>
//#include <string>
//#include <vector>
//#include <locale>
//#include <assert.h>
//using namespace std;
//typedef unsigned char byte;
//#define MIN(a,b)    (((a) < (b)) ? (a) : (b))
//class FastDW
//{
//public:
//    FastDW()
//    {
//    }
//    FastDW( vector<wstring> const & dirtyWords )
//    {
//        init( dirtyWords );
//    }
//    ~FastDW()
//    {
//        clearBuffer();
//    }
//    inline void clearBuffer()
//    {
//        for( auto& buf : _bufs ) delete[] buf;
//        _bufs.clear();
//    }
//    inline void init( vector<wstring> const & dirtyWords )
//    {
//        _maxLength = 0;
//        clearBuffer();
//        for( auto const & word : dirtyWords )
//            if( _maxLength < word.size() )
//                _maxLength = word.size();
//        for( int i = 0; i < _maxLength; ++i )
//        {
//            auto buf = new char[ 65536 ];
//            memset( buf, 0, 65536 );
//            _bufs.push_back( buf );
//        }
//
//        for( size_t i = 0; i < _maxLength; ++i )
//        {
//            for( auto const & word : dirtyWords )
//            {
//                if( i >= word.size() ) continue;
//                auto &c = word[ i ];
//                if( i == word.size() - 1 )
//                    _bufs[ i ][ c ] = 1;
//                else
//                    if( _bufs[ i ][ c ] != 1 )
//                        _bufs[ i ][ c ] = 2;
//            }
//        }
//    }
//    inline wstring calc( wstring const & s ) const
//    {
//        assert( _bufs.size() );
//        wstring o;
//        o.reserve( s.size() );
//        int lastMatch;
//        for( size_t offset = 0; offset < s.size(); ++offset )
//        {
//            lastMatch = -1;
//            for( size_t i = 0; i < MIN( _maxLength, s.size() - offset ); ++i )
//            {
//                auto& v = _bufs[ i ][ s[ offset + i ] ];
//                if( v == 0 ) break;
//                else if( v == 1 ) lastMatch = (int)i;
//            }
//            if( lastMatch == -1 )
//            {
//                o.push_back( s[ offset ] );
//            }
//            else
//            {
//                o.append( lastMatch + 1, '*' );
//                offset += lastMatch;    // for will + 1
//            }
//        }
//        return o;
//    }
//private:
//    vector<char*> _bufs;
//    size_t _maxLength;
//    FastDW( FastDW const & other ) = delete;
//    FastDW operator=( FastDW const & other ) = delete;
//};
//int main()
//{
//    vector<wstring> words =
//    {
//        L"²ÙÄã",
//        L"²ÙÄã´óÒ¯",
//        L"²ÙÄãÂè",
//    };
//    wstring s = L"ÎÒ²ÙÄã´óÒ¯,²ÙÄãÈ«¼Ò!²Ù";
//    FastDW fdw( words );
//    auto o = fdw.calc( s );
//
//    setlocale( LC_ALL, "chs" );
//    std::wcout << o << endl;
//}




























